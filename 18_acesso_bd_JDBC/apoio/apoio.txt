- [BANCO DE DADOS - COMPREENDENDO]

1 - O que é um Banco de Dados?

        Um banco de dados é uma coleção organizada de dados. Esses dados são estruturados de forma a permitir o 
        armazenamento, recuperação, atualização e gerenciamento eficientes.

2 - Sistemas de Gerenciamento de Bancos de Dados (SGBD):

        Os SGBDs são softwares que fornecem uma interface para interagir com o banco de dados. Exemplos incluem 
        MySQL, PostgreSQL, Oracle, SQL Server, SQLite, entre outros.

3 - Modelo Relacional:

        Muitos bancos de dados seguem o modelo relacional, onde os dados são organizados em tabelas com linhas (registros) 
        e colunas (campos). Relacionamentos entre tabelas são estabelecidos por meio de chaves.

4 - SQL (Structured Query Language):

        SQL é uma linguagem usada para consultar e manipular dados em bancos de dados relacionais. Ela inclui comandos como 
        SELECT, INSERT, UPDATE, DELETE para realizar operações no banco de dados.

5 - Tabelas e Esquemas:

        Tabelas são estruturas fundamentais que armazenam os dados. Cada tabela tem um conjunto específico de colunas e cada coluna
        possui um tipo de dados associado. Conjuntos de tabelas formam esquemas.

6 - Chaves Primárias e Estrangeiras:

        Chaves primárias são identificadores únicos em uma tabela, enquanto chaves estrangeiras são usadas para estabelecer relacionamentos 
        entre tabelas.

7 - Normalização:

        Normalização é o processo de organizar dados para reduzir a redundância e dependência. Isso ajuda a evitar problemas como a inserção,
        atualização ou exclusão de dados que poderiam resultar em inconsistências.

8 - Backup e Recuperação:

        A segurança dos dados é crucial. Isso inclui a realização regular de backups para evitar perda de dados e a implementação de práticas 
        de recuperação em caso de falhas.

9 - Índices:

        Índices são estruturas que melhoram a velocidade de recuperação de dados em consultas. Eles são semelhantes aos índices em livros, 
        tornando mais fácil encontrar informações específicas.

10 - Segurança e Permissões:

        Os SGBDs oferecem recursos para controlar o acesso aos dados. É importante entender como conceder permissões e garantir a segurança dos 
        dados sensíveis.

11 - Conceitos de Transação:

        Transações garantem a integridade dos dados, garantindo que um conjunto de operações seja executado como uma única unidade.

Esses são apenas alguns conceitos básicos. À medida que você avança, você pode explorar tópicos mais avançados, como otimização de consultas, modelagem de dados, 
procedimentos armazenados, triggers, entre outros. Prática e experiência são fundamentais, então, à medida que aprende, tente aplicar seus conhecimentos em projetos práticos.


=======> Como surge um banco de dados?
        Surge a partir de uma gereralização pensada (Requisito de software)
        que atende aos parâmetros de uma necessidade.

        Se baseia em que variáveis precisam associadas ao banco a partir de uma entidade

        Cliente -> Nome, idade, email,..., id.



[PROBLEMA 1]
O cliente Tera Comércio de Produtos S.A, solicitou a modelagem de um banco de dados para cadastro dos seus clientes.
A função da Unidados é a análise dos requisitos junto aos usuários para a correta construção do produto. O cliente deseja que 
,inicialmente os scripts sejam construídos para o Banco de Dados MySQL, porém, posteriormente pode haver mudança no ambiente e consequentemente 
adaptação dos scripts para outros produtos de SGBD.

O cliente não quer nenhuma informação relativa à vendas ou estoque, desejando somente as informações primárias de Clientes

/* MODELAGEM BÁSICA - ENTIDADE = TABELA */ 
/*
CLIENTE

NOME - CARACTER(30)
CPF - NUMERICO(11)
EMAIL - CARACTERE(30)
TELEFONE - CARACTERE(30)
ENDERECO - CARACTERE(100)
SEXO - CARACTERE(1)

/* PROCESSOS DE MODELAGEM */

/* FASE 01 E FASE 02 - FEITAS PELO ADMINISTRADOR DE DADOS */
/*
MODELAGEM CONCEITUAL - RASCUNHO(CONVERSA DE COMO SERÁ MODELADO)
MODELAGEM LÓGICA - APLICA O RASCUNHO A UM MODELO LÓGICO, EX: UML, QUALQUER PROGRAMA DE MODELAGEM
/* FASE 03 - DBA OU AD */ 
/*
MODELAGEM FÍSICA - SCRIPTS DE BANCO - SQL + TIPAGEM DE DADOS
*/

/* INCIANDO MODELAGEM FÍSICA */ 


>>>>>>>>>>>>>>> SINTAXE <<<<<<<<<<<<<<<<<<


/* Criando banco de dados */ 

CREATE DATABASE EXEMPLO;

CREATE DATABASE PROJETO;

/* MAS E AÍ, COMO SABER QUAL ESTOU USANDO? OBS: NÃO SE PODE CRIAR O DB COM MESMO NOME */

/* CONECTANDO-SE AO BANCO */

USE PROJETO;

/* CRIANDO A TABELA DE CLIENTES */

CREATE TABLE CLIENTE(
	
	NOME VARCHAR(30),
	SEXO CHAR(1),
	EMAIL VARCHAR(30),
	CPF INT(11),
	TELEFONE VARCHAR(30),
	ENDERECO VARCHAR(100)
);

/* VERIFICANDO AS TABELAS DO BANCO */ 

SHOW TABLES;

USE EXEMPLO;
SHOW TABLES;

USE PROJETO

/* DESCOBRINDO COMO É A ESTRUTURA DE UMA TABELA (O QUE COMPOE A TABELA?) */

DESC PROJETO;

[FALANDO SOBRE TUNNING] ----> A PERFORMANCE DE UM BANCO A PARTIR DA ANALISE DOS TIPOS.

- CHAR E VARCHAR

        . Cada char vale 1byte 
        EX:
                NOME CHAR(10) -> Usuario com nome João = [J][O][A][O][][][][][][] -> 6 espaços ocupados por " ".
                O resultado é mais dados desnecessários circulando nos campos, consequentemente tornando mais pesado.

                NOME VARCHAR(10) -> [J][O][A][O] - Alocado e descartado os 6 espaços restantes - dinâmica do VARCHAR

        . Porém o char é mais performático, pois não depende da variancia do numero de caracteres do dado inserido.

        DICA => USAR CHAR QUANDO: O NUMERO DE CARACTERES DA COLUNA NUNCA FOR VARIANTE.
        ex: unidades federativas RJ, SP, AM, PR, SC, ..., ES.

 - ENUM -> ENUMERAÇÃO

        .


 CREATE TABLE PRODUTO(

	ID INTEGER,
	NOME VARCHAR(30),
	PREÇO DOUBLE
	
);

/* SINTAXE BÁSICA DE INSERÇÃO - INSERT INTO... ("..." - VARIA DE BANCO PRA BANCO)*/

/* FORMA 01 - EXCLUINDO COLUNAS */
/* VALORES DEVEM SER INSERIDOS NA EXATA ORDEM EM QUE ESTÃO NO BANCO */

INSERT INTO CLIENTE VALUES('JOAO','M','JOAO@GMAIL.COM',988638273,'22923110','MAIA LACERDA - ESTACIO - RIO DE JANEIRO - RJ');

INSERT INTO CLIENTE VALUES('CELIA','F','CELIA@GMAIL.COM',541521456,'25078869','RIACHUELO - CENTRO - RIO DE JANEIRO - RJ');

INSERT INTO CLIENTE VALUES('JORGE','M',NULL,885755896,'58748895','OSCAR CURY - BOM RETIRO - PATOS DE MINAS - MG');
/* SE NULL NÃO FOSSE INSERIDO, O CAMPO 'EMAIL', SERIA LIDO COMO TELEFONE(885755896) (BAD METHOD) */


/* FORMA 02 - COLOCANDO AS COLUNAS */

INSERT INTO CLIENTE(NOME,SEXO,ENDERECO,TELEFONE,CPF) VALUES('LILIAN','F','SENADOR SOARES - TIJUCA - RIO DE JANEIRO - RJ','947785696',887774856);
/* Especificação da ordem de entrada e omissão do campo Email, validado como NULL */

/* FORMA 03 - INSERT COMPACTO - SOMENTE MYSQL */

INSERT INTO CLIENTE VALUES('ANA','F','ANA@GLOBO.COM',85548962,'548556985','PRES ANTONIO CARLOS - CENTRO - SAO PAULO - SP'),
                          ('CARLA','F','CARLA@TERATI.COM.BR',7745828,'66587458','SAMUEL SILVA - CENTRO - BELO HORIZONTE - MG');
						  

/* ERRO: OUT OF RANGE - APESAR DE SER 9 DIGITOS NO CPF - MAS POR QUE? */
INSERT INTO CLIENTE(NOME,SEXO,ENDERECO,TELEFONE,CPF) VALUES('CLARA','F','SENADOR SOARES - TIJUCA - RIO DE JANEIRO - RJ','424555696',88777485611);

INSERT INTO CLIENTE(NOME,SEXO,ENDERECO,TELEFONE,CPF) VALUES('MARCELA','F','SENADOR SOARES - TIJUCA - RIO DE JANEIRO - RJ','424555696',23456789111);
/* OS NUMEROS INSERIDOS ULTRAPASSAM O LIMITE ESTABELECIDO PELO TIPO INT */

/* 
	-> O COMANDO SELECT
	EXSITEM CARACTERÍSTICAS SEMPRE PRESENTES -> SELEÇÃO PROJEÇÃO E JUNÇÃO
*/

/* =================== PROJEÇÕES =================== */

/* "É O QUE VOCE QUER VER" - SE QUER VER TAL COISA, É PROJEÇÃO(SELECT FROM .....)*/

/* SELECT NÃO É SELEÇÃO, É PROJEÇÃO */

SELECT NOW() as DATA_HORA, 'LUIZ OTAVIO' AS ALUNO;

SELECT 'FELIPE MAFRA';

SELECT 'BANCO DE DADOS';

/* ALIAS DE COLUNAS - ORDEM A MEU CRITÉRIO */

SELECT NOME, SEXO, EMAIL FROM CLIENTE;

SELECT NOME AS CLIENTE, SEXO, EMAIL, ENDERECO FROM CLIENTE;

SELECT NOME AS CLIENTE, SEXO, EMAIL, ENDERECO, NOW() FROM CLIENTE;

/* USAR SOMENTE PARA FINS ACADÊMICOS  - SELECIONA TUDO DA TABELA */
/* SELECIONA A TABELA SEM NENHUM CRITÉRIO DE BUSCA - IMAGINAR PARA SITUAÇÕES ONDE O BANOC ESTÁ SOBRECARREGADO */
SELECT * FROM CLIENTE;

/* FILTROS */

/* RETORNA TABELA INTEIRA, NÃO É IDEAL PARA GRANDES TABELAS */
SELECT * FROM CLIENTE;

/* 
	PROJEÇÃO: SELECT
	SELEÇÃO: WHERE
*/

/* FILTRANDO */

SELECT NOME, SEXO FROM CLIENTE
WHERE SEXO = 'M';

SELECT NOME, ENDERECO FROM CLIENTE
WHERE SEXO = 'F';

SELECT NOME, SEXO FROM CLIENTE
WHERE ENDERECO = 'RJ';

/* UTILIZANDO O LIKE */

SELECT NOME, SEXO FROM CLIENTE
WHERE ENDERECO LIKE 'RJ';

/* O SQL ACIMA AINDA NÃO FUNCIONA, MAS POR QUE? */
/* CARACTER CORINGA  % -> QUER DIZER QUALQUER COISA */

SELECT NOME, SEXO FROM CLIENTE
WHERE ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE ENDERECO LIKE '%TIJUCA%';

/* EXERCÍCIO DADOS DOS LIVROS */

CREATE DATABASE LIVRARIA;

USE LIVRARIA;

CREATE TABLE LIVROS(
	NOME_LIVRO VARCHAR(255),	
	NOME_AUTOR VARCHAR(255),
	SEXO_AUTOR VARCHAR(30),
	NUMERO_PAGINAS INT,
	NOME_EDITORA VARCHAR(255),
	VALOR_LIVRO DECIMAL(10,2),
	UF_EDITORA CHAR(2),
	ANO_PUBLICACAO INT
);

INSERT INTO LIVROS (NOME_LIVRO, NOME_AUTOR, SEXO_AUTOR, NUMERO_PAGINAS, NOME_EDITORA, VALOR_LIVRO, UF_EDITORA, ANO_PUBLICACAO)
VALUES 
('Cavaleiro Real', 'Ana Claudia', 'Feminino', 465, 'Atlas', 49.9, 'RJ', 2009),
('SQL para leigos', 'João Nunes', 'Masculino', 450, 'Addison', 98, 'SP', 2018),
('Receitas Caseiras', 'Celia Tavares', 'Feminino', 210, 'Atlas', 45, 'RJ', 2008),
('Pessoas Efetivas', 'Eduardo Santos', 'Masculino', 390, 'Beta', 78.99, 'RJ', 2018),
('Habitos Saudáveis', 'Eduardo Santos', 'Masculino', 630, 'Beta', 150.98, 'RJ', 2019),
('A Casa Marrom', 'Hermes Macedo', 'Masculino', 250, 'Bubba', 60, 'MG', 2016),
('Estacio Querido', 'Geraldo Francisco', 'Masculino', 310, 'Insignia', 100, 'ES', 2015),
('Pra sempre amigas', 'Leda Silva', 'Feminino', 510, 'Insignia', 78.98, 'ES', 2011),
('Copas Inesqueciveis', 'Marco Alcantara', 'Masculino', 200, 'Larson', 130.98, 'RS', 2018),
('O poder da mente', 'Clara Mafra', 'Feminino', 120, 'Continental', 56.58, 'SP', 2017);


/* 1 - TRAZER TODO OS DADOS : */

SELECT * FROM LIVROS;

/* 2 - TRAZER O NOME DO LIVRO E DA EDITORA : */

SELECT NOME_LIVRO, NOME_EDITORA FROM LIVROS;

/* 3 - TRAZER O NOME DO LIVRO E UF DOS LIVROS PUBLICADOS POR MASCULINOS : */

SELECT NOME_LIVRO, UF_EDITORA FROM LIVROS WHERE SEXO_AUTOR = 'Masculino';

/* 4 - TRAZER O NOME DO LIVRO E NUMERO DE PAGINAS PUBLICADOS POR FEMININO : */

SELECT NOME_LIVRO, NUMERO_PAGINAS FROM LIVROS WHERE SEXO_AUTOR = 'Feminino';

/* 5 - TRAZER OS VALORES DOS LIVROS DAS EDITORAS DE SÃO PAULO : */

SELECT VALOR_LIVRO AS PRECO FROM LIVROS WHERE UF_EDITORA = 'SP';

/* 6 - (DESAFIO) TRAZER OS DADOS DOS AUTORES DO SEXO MASC QUE TIVERAM LIVROS PUBLICADOS POR SP
OU RJ
: */

SELECT NOME_AUTOR FROM LIVROS WHERE SEXO_AUTOR = 'Masculino' AND (UF_EDITORA = 'RJ' OR UF_EDITORA = 'SP');

/* OPERADORES LÓGICOS */
/* AND - OR */

SELECT NOME_AUTOR FROM LIVROS WHERE SEXO_AUTOR = 'FEMININO' OR UF_EDITORA = 'RJ';

SELECT NOME_AUTOR FROM LIVROS WHERE SEXO_AUTOR = 'FEMININO' AND NUMERO_PAGINAS > 100;

/* OPERADORES LÓGICOS 
OR -> PARA QUE A SAIDA DA QUERY SEJA VERDADEIRA, BASTA QUE APENAS UMA CONDICAO SEJA VERDADEIRA.
AND -> PARA QUE A SAIDA SEJA VERDADEIRA TODAS AS CONDICOES PRECISAM SER VERDADEIRAS.
*/

/* OR - OU */

SHOW DATABASES;

USE PROJETO;

SELECT * FROM CLIENTE;

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE 
SEXO = 'M' OR ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE 
SEXO = 'M' AND ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO  FROM CLIENTE
WHERE
SEXO = 'F' OR ENDERECO LIKE '%ESTACIO';

/* AND - E */

SELECT NOME, SEXO, ENDERECO  FROM CLIENTE
WHERE 
SEXO = 'M' AND ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE
SEXO = 'F' AND ENDERECO LIKE '%ESTACIO';

/* COUNT(*), GROUP BY, PERFORMANCE COM OPERADORES LÓGICOS */

/* CONTANDO REGISTROS DE UMA TABELA */

SELECT COUNT(*) FROM LIVROS;

/* OPERADOR GROUP BY */

/* error */
SELECT SEXO, COUNT(*) FROM CLIENTE;
/* O RESULTADO EXIBIDO É | M | 6 | PORQUE A FUNÇÃO DE AGREGAÇÃO COUNT(*)
RETORNA SOMENTE UMA LINHA, ENQUANTO 'SEXO' RETORNA 6, GERANDO O ERRO.
*/

/* SOLUÇÃO */

SELECT SEXO, COUNT(*) FROM CLIENTE GROUP BY SEXO;
/* E O QUE O GROUP BY FAZ AQUI? A QUERY EXPLICITA QUE A AGRUPAÇÃO DEVE SER POR CADA SEXO EXISTENTE 
(POR CADA ITEM SEXO EXISTENTE) - AGRUPA POR SEXO.
*/

SELECT SEXO, COUNT(*) AS 'QUANTIDADE DE MULHERES' FROM CLIENTE WHERE SEXO = 'F' GROUP BY SEXO;

/* MINHAS QUERYS */

SELECT UF_EDITORA, COUNT(*) FROM LIVROS GROUP BY UF_EDITORA;
SELECT UF_EDITORA, COUNT(*) FROM LIVROS WHERE NUMERO_PAGINAS > 600 GROUP BY UF_EDITORA;

/* PERFORMANCE EM OPERADORES LÓGICOS */

/* 1 MILHAO DE REGISTROS

PARA CONTAR
SELECT COUNT(*) FROM CLIENTE;

SELECT SEXO, COUNT(*) FROM CLIENTE
GROUP BY SEXO;

SELECT CIDADE, COUNT(*) FROM CLIENTE
GROUP BY CIDADE;

CONDICAO
SEXO = F
CIDADE = RIO DE JANEIRO

SITUACAO - TRATANDO COM OU / OR
70% MULHERES = SEXO = F
30% MORA NO RIO DE JANEIRO

SELECT NOME, SEXO, ENDERECO
FROM CLIENTE
WHERE SEXO = 'F'
OR CIDADE = 'RIO DE JANEIRO';

SITUACAO - TRATANDO COM E / AND
70% MULHERES = SEXO = F
30% MORA NO RIO DE JANEIRO

SELECT NOME, SEXO, ENDERECO
FROM CLIENTE
WHERE CIDADE = 'RIO DE JANEIRO'
AND SEXO = 'F';

/* EXERCÍCIO */

/* Considerando o que vc aprendeu sobre performance, resolva os exercicios abaixo */

/* 
--Traga os funcionarios que trabalhem
--no departamento de filmes OU no
--departamento de roupas

-> MINHA SOLUÇÃO: 
SELECT DEPARTAMENTO, COUNT(*) FROM FUNCIONARIOS WHERE DEPARTAMENTO = 'FILMES' 
OR DEPARTAMENTO = 'ROUPAS' GROUP BY DEPARTAMENTO;

SELECT NOME FROM FUNCIONARIOS WHERE DEPARTAMENTO = 'ROUPAS' OR DEPARTAMENTO = 'FILMES';

OCORRENCIA MAIOR DO DEP 'ROUPAS' SEGUNDO A PRIMEIRA QUERY, ENTÃO 
ROUPAS É O PRIMEIRO ARGUMENTO NA CLAUSULA WHERE OR;

PROFESSOR:

SELECT * FROM FUNCIONARIOS WHERE DEPARTAMENTO = 'ROUPAS' OR DEPARTAMENTO = 'FILMES';


*/

/* 
--O gestor de marketing pediu a lista das funcionarias (AS) = FEMININO que trabalhem no departamento 
--de filmes ou no departamento lar. Ele necessita enviar um email para as colaboradoras
--desses dois setores.

-> MINHA SOLUÇÃO:

SELECT SEXO, COUNT(*) FROM FUNCIONARIOS GROUP BY SEXO;

SELECT DEPARTAMENTO, COUNT(*) FROM FUNCIONARIOS WHERE SEXO = 'FEMININO' 
AND (DEPARTAMENTO = 'FILMES' OR DEPARTAMENTO = 'LAR') GROUP BY DEPARTAMENTO;

SELECT NOME FROM FUNCIONARIOS WHERE SEXO = 'FEMININO' AND (DEPARTAMENTO = 'LAR' OR DEPARTAMENTO = 'FILMES');

CORREÇÃO:
 
EXISTEM 491 OCORRENCIAS DO (SEXO = FEMININO) E (52[LAR] OU 21[FILMES )

O MENOR DEVE TER PREFERENCIA AO PRIMEIRO PARAMETRO DA CLAUSULA, POIS FARÁ
COM QUE O 'CHECK DE CONDIÇÃO' VÁ MENOS VEZES VER SE A CONDIÇÃO ESTÁ SENDO ATENDIDA

EX: SEXO(FEMININO) -> 491 OCORRENCIAS;
	AND
	...
	O CHECK IRIA 491 VEZES VERIFICAR SE A LINHA ATENDE A CONDIÇÃO.
	
SELECT NOME FROM FUNCIONARIOS WHERE (DEPARTAMENTO = 'LAR' AND SEXO  = 'FEMININO')  
OR 
(DEPARTAMENTO = 'FILMES' AND SEXO = 'FEMININO') ;



*/ 

--Traga os funcionarios do sexo masculino
--ou os funcionarios que trabalhem no setor Jardim

-> MINHA SOLUÇÃO: 
SELECT DEPARTAMENTO, COUNT(*) FROM FUNCIONARIOS WHERE DEPARTAMENTO = 'FILMES' 
OR DEPARTAMENTO = 'ROUPAS' GROUP BY DEPARTAMENTO;

SELECT NOME FROM FUNCIONARIOS WHERE DEPARTAMENTO = 'ROUPAS' OR DEPARTAMENTO = 'FILMES';

OCORRENCIA MAIOR DO DEP 'ROUPAS' SEGUNDO A PRIMEIRA QUERY, ENTÃO 
ROUPAS É O PRIMEIRO ARGUMENTO NA CLAUSULA WHERE OR;

PROFESSOR:

SELECT * FROM FUNCIONARIOS WHERE DEPARTAMENTO = 'ROUPAS' OR DEPARTAMENTO = 'FILMES';


*/

/* 
--O gestor de marketing pediu a lista das funcionarias (AS) = FEMININO que trabalhem no departamento 
--de filmes ou no departamento lar. Ele necessita enviar um email para as colaboradoras
--desses dois setores.

-> MINHA SOLUÇÃO:

SELECT SEXO, COUNT(*) FROM FUNCIONARIOS GROUP BY SEXO;

SELECT DEPARTAMENTO, COUNT(*) FROM FUNCIONARIOS WHERE SEXO = 'FEMININO' 
AND (DEPARTAMENTO = 'FILMES' OR DEPARTAMENTO = 'LAR') GROUP BY DEPARTAMENTO;

SELECT NOME FROM FUNCIONARIOS WHERE SEXO = 'FEMININO' AND (DEPARTAMENTO = 'LAR' OR DEPARTAMENTO = 'FILMES');

CORREÇÃO:
 
EXISTEM 491 OCORRENCIAS DO (SEXO = FEMININO) E (52[LAR] OU 21[FILMES )

O MENOR DEVE TER PREFERENCIA AO PRIMEIRO PARAMETRO DA CLAUSULA, POIS FARÁ
COM QUE O 'CHECK DE CONDIÇÃO' VÁ MENOS VEZES VER SE A CONDIÇÃO ESTÁ SENDO ATENDIDA

EX: SEXO(FEMININO) -> 491 OCORRENCIAS;
	AND
	...
	O CHECK IRIA 491 VEZES VERIFICAR SE A LINHA ATENDE A CONDIÇÃO.
	
SELECT NOME FROM FUNCIONARIOS WHERE (DEPARTAMENTO = 'LAR' AND SEXO  = 'FEMININO')  
OR 
(DEPARTAMENTO = 'FILMES' AND SEXO = 'FEMININO') ;



*/ 

--Traga os funcionarios do sexo masculino
--ou os funcionarios que trabalhem no setor Jardim

/* 
SELECT NOME, DEPARTAMENTO FROM FUNCIONARIOS WHERE SEXO = 'MASCULINO' OR DEPARTAMENTO = 'JARDIM';
*/

/* FILTRANDO VALORES NULOS */

/* Minha query - é assim(filtragem de null)*/
SELECT * FROM CLIENTE WHERE EMAIL IS NULL;
/* Filtrando valores não null */
SELECT * FROM CLIENTE WHERE EMAIL IS NOT NULL;

/* IS ou IS NOT */ 

/*=======================UTILIZANDO UPDATE PARA ATUALIZAR VALORES */
 
SELECT NOME, EMAIL FROM CLIENTE;

UPDATE CLIENTE SET EMAIL = "LUIZ@GMAIL.COM";
 /* VAI ALTERAR O EMAIL DE TODAS AS PESSOAS DA TABELA - UTILIZAR BEM O WHERE - MELHOR AMIGO*/

/* MINHA QUERY */
/* É ASSIM QUE SE DÁ UPDATE */
UPDATE CLIENTE SET EMAIL = 'LUIZ@GMAIL.COM' WHERE NOME = 'LUIZ';

UPDATE CLIENTE SET EMAIL = 'DEFAULT@GMAIL.COM';

+---------+------+-------------------+-----------+-------------+-----------------------------------------------+
| NOME    | SEXO | EMAIL             | CPF       | TELEFONE    | ENDERECO                                      |
+---------+------+-------------------+-----------+-------------+-----------------------------------------------+
| JOAO    | M    | DEFAULT@GMAIL.COM | 988638273 | 22923110    | MAIA LACERDA - ESTACIO - RIO DE JANEIRO - RJ  |
| CELIA   | F    | DEFAULT@GMAIL.COM | 541521456 | 25078869    | RIACHUELO - CENTRO - RIO DE JANEIRO - RJ      |
| JORGE   | M    | DEFAULT@GMAIL.COM | 885755896 | 58748895    | OSCAR CURY - BOM RETIRO - PATOS DE MINAS - MG |
| LILIAN  | F    | DEFAULT@GMAIL.COM | 887774856 | 947785696   | SENADOR SOARES - TIJUCA - RIO DE JANEIRO - RJ |
| ANA     | F    | DEFAULT@GMAIL.COM |  85548962 | 548556985   | PRES ANTONIO CARLOS - CENTRO - SAO PAULO - SP |
| CARLA   | F    | DEFAULT@GMAIL.COM |      NULL | 66587458    | SAMUEL SILVA - CENTRO - BELO HORIZONTE - MG   |
| LUIZ    | M    | DEFAULT@GMAIL.COM |  43628304 | 18988113681 | AP CHAGAS MOREIRA                             |
| ROBERTO | M    | DEFAULT@GMAIL.COM | 436666666 | 18995555555 | Apartamento                                   |
+---------+------+-------------------+-----------+-------------+-----------------------------------------------+

UPDATE CLIENTE SET EMAIL = 'JOAO@GMAIL.COM' WHERE NOME = 'JOAO';
UPDATE CLIENTE SET EMAIL = 'CELIA@GMAIL.COM' WHERE NOME = 'CELIA';
UPDATE CLIENTE SET EMAIL = 'JORGE@GMAIL.COM' WHERE NOME = 'JORGE';
UPDATE CLIENTE SET EMAIL = 'LILIAN@GMAIL.COM' WHERE NOME = 'LILIAN';
UPDATE CLIENTE SET EMAIL = 'ANA@GMAIL.COM' WHERE NOME = 'ANA';
UPDATE CLIENTE SET EMAIL = 'CARLA@GMAIL.COM' WHERE NOME = 'CARLA';
UPDATE CLIENTE SET EMAIL = 'LUIZ@GMAIL.COM' WHERE NOME = 'LUIZ';
UPDATE CLIENTE SET EMAIL = 'ROBERTO@GMAIL.COM' WHERE NOME = 'ROBERTO';

/* CASO FIZESSE ISSO EM UMA DB MUITO GRANDE, COMO RESOLVER? */
/* EXISTEM OS COMANDOS COMMIT E ROLLBACK */

/* DUVIDA: COMO FILTRAR OS CLIENTES QUE ESTÃO COM ALGUM CAMPO NULL? */

SELECT *
FROM Cliente
WHERE NOME IS NULL OR SEXO IS NULL OR EMAIL IS NULL OR CPF IS NULL OR TELEFONE IS NULL OR ENDERECO IS NULL;

/* FORMA MAIS AVANÇADA */

SELECT *
FROM Cliente
WHERE CONCAT(NOME, SEXO, EMAIL, CPF, TELEFONE, ENDERECO) IS NULL;

/* DELETANDO REGISTROS COM A CLAUSULA DELETE */

DELETE FROM CLIENTE; /* vai apagar tudo */

SELECT COUNT(*) FROM CLIENTE WHERE NOME = 'ANA';

DELETE FROM CLIENTE WHERE NOME = 'ANA';

SELECT COUNT(*) FROM CLIENTE; /* A CONTAGEM VAI SER MENOR DO QUE A CONTAGEM FEITA ANTES DO COMANDO ACIMA */

/* SITUAÇÃO DESCRITA */
/* EXISTENCIA DE CLIENTES COM O MESMO NOME, EXCLUSÃO A PARTIR DO NOME. RESULTA EM TODOS EXCLUIDOS */

INSERT INTO CLIENTE VALUES('LUIZ', 'M', 'OTAVIO@GMAIL.COM', 43628486, '18998111111', 'Centro - SP ');

/* SEMPRE ESPECIFICAR MAIS OS ARGUMENTOS  */
DELETE FROM CLIENTE WHERE NOME = 'LUIZ' AND CPF IS NULL;

/* =================================================================== */
/* =================================================================== */
	
	/* MODELANDO BANCO DE DADOS PARA SISTEMAS */
	
	/*
	NA PRIMEIRA AULA O PROFESSOR RETRATA OS ERROS COMETIDOS ATÉ AGORA, APESAR 
	DO USO CORRETO DE TODOS OS COMANDOS APRENDIDOS, OS DADOS ESTÃO DISPOSTOS DE UMA FORMA
	INCORRETA.
	*/
	
	/* PRIMEIRA FORMA NORMAL */
	
	/* 
	
	---------------------------------------------
	1 - TODO CAMPO VETORIZADO SE TORNARÁ OUTRA TABELA;
	
	[AMARELO, LARANJA, AZUL, VERMELHO] - VETOR DE CORES	
	
	COMO ASSIM CAMPO VETORIZADO?
	
	LEMBRAR DOS VETORES NA PROGRAMAÇÃO
	COMO NO EXEMPLO ACIMA, IMAGINE QUE EXISTA UM O ATRIBUTO CORES
	PARA DEFINIR QUAIS CORES O OBJETO POSSUI
	
	ISSO É UM CAMPO VETORIZADO, POR QUE?
	
	PORQUE ESSE ATRIBUTO CONTÉM MAIS DO QUE UMA UNICA COR.
	
	---------------------
	
	2 - TODO CAMPO MULTIVALORADO SE TORNARÁ OUTRA TABELA 
	QUANDO O CAMPO FOR DIVISÍVEL
	
	---------------------
	
	3 - TODA TABELA NECESSITA DE PELO MENOS UM CAMPO QUE IDENTIFIQUE 
	TODO O REGISTRO COMO SENDO UNICO
	
	É O QUE CHAMAMOS DE CHAVE PRIMÁRIA OU PRIMARY KEY
	
	IDEIA: NA TABELA CLIENTE, A CHAVE PRIMÁRIA PODERIA SER O CPF?
	A PRINCÍPIO SIM, MAS NÃO. O CPF É UM 'NEGÓCIO' SOB DOMÍNIO DO GOVERNO
	E SE ELES DECIDIREM MUDAR? O CPF DEIXARIA DE EXISTIR E TODO O BANCO SERIA INVÁLIDADO.
	
	EXISTEM DOIS TIPOS DE CHAVE
	
	NATURAL - CPF - REALMENTE PERTENCE A LINHA (DADOS DO USUARIO)
	
	ARTIFICIAL - ID, SENHA DE ATENDIMENTO, TICKET - UMA ORDENAÇÃO DESENVOLVIDA PARA ORGANIZAÇÃO, IDENTIFICAÇÃO
	E PRECEDENCIA -> MUITO MAIS USADA ATUALMENTE
	
	------------------------------------
	
	-> CARDINALIDADE E OBRIGATORIEDADE
	
	************************************
			MODELAGEM LÓGICA
	************************************
	
	Obrigatoriedade 
		Trata de visar se é obrigatorio ou não
		a entrada de um campo
		
		1 - verdadeiro (obrigatorio)
		0 - falso (não é obrigatorio)
		
		
	Cardinalidade 
		Trata do maximo de ocorrencias, enquanto OBRIGATORIEDADE
		trata de acontecer ou não.
	
	(obrigatoriedade, cardinalidade)
	(0, n)
	(0, 1)
	(1, n)
	(1, 1)

	(x, y)
	x -> Obrigatoriedade 
	y -> Cardinalidade
	
	TELEFONE 
	(0, n)
	Não é obrigatorio
	mas pode haver muitos
	
	ENDERECO 
	(1, 1) 
	É obrigatorio
	só pode haver um
	
	CLIENTE
	2X (1,1)
	Obrigatorio para cada campo vetorizado(para existencia dele)
	no maximo 1
	
	---> (RELAÇÕES ABAIXO)
	DEVE CRUZAR OS INDICES y das relações
	
	CLIENTE -> TELEFONE
	(1, "1")     (0, "n") 
	(1, n)
	
	CLIENTE -> ENDERECO
	(1, "1")     (1, "1") 
	(1, 1)
	
	*/
	
	************************************
			MODELAGEM FÍSICA
	************************************
	
	CREATE DATABASE COMERCIO;
	
	USE COMERCIO;
	
	CREATE TABLE CLIENTE(
	
		IDCLIENTE INT PRIMARY KEY AUTO_INCREMENT,
		NOME VARCHAR(60) NOT NULL,
		SEXO ENUM('M','F') NOT NULL,
		EMAIL VARCHAR(50) UNIQUE,
		CPF VARCHAR(15) UNIQUE
	
	);
	
	/* ENUM SÓ FUNCIONA NO MYSQL */
	
	/* EMAIL NÃO É UM CAMPO EXIGIDO(DEPENDE DA REGRA DE NEGOCIO)
	PORÉM, NÃO SE PODE PERMITIR QUE USUARIOS DISTINDOS USEM O MESMO
	EMAIL
	
	
	COMO FAZER ISSO? "UNIQUE"
	
	*/

        CREATE TABLE ENDERECO(	
		IDENDERECO INT PRIMARY KEY AUTO_INCREMENT,
		RUA VARCHAR(30) NOT NULL,
		BAIRRO VARCHAR(30) NOT NULL,
		CIDADE VARCHAR(30) NOT NULL,
		ESTADO CHAR(2) NOT NULL
	);
	
	CREATE TABLE TELEFONE(
	
		IDTELEFONE INT PRIMARY KEY AUTO_INCREMENT,
		TIPO ENUM('RES', 'COM', 'CEL') NOT NULL,
		NUMERO VARCHAR(10) NOT NULL
	);
	
	
	/* 
		APESAR DE CRIADAS AS 3 TABELAS
		ELAS AINDA NÃO ESTÃO RELACIONADAS
		COM A TABELA CLIENTE

		ENDERECO - Obrigatorio
		CADASTRO DE SOMENTE 1
		
		TELEFONE - NÃO obrigatorio
		CADASTRO DE MAIS DE UM (OPCIONAL)


	
	/*
		FK - FOREIGN KEY
		
		CHAVE ESTRANGEIRA É A CHAVE PRIMARIA DE 
		UMA TABELA QUE VAI ATÉ A OUTRA TABELA PARA 
		FAZER REFERENCIA ENTRE OS REGISTROS.
		
		
	*/
	
	/* 
	
	
	======== QUEM RECEBE A CHAVE ESTRANGEIRA? 
	
		EM RELACIONAMENTO 1 X 1 A CHAVE ESTRANGEIRA
		FICA NA TABELA MAIS FRACA
	
		EM RELACIONAMENTOS 1 X N A CHAVE ESTRANGEIRA
		FICARÁ SEMPRE NA CARDIALIDADE N

	*/
	
	/* 
		SINTAXE PARA RELAÇÃO DE TABELAS
		
		ID_CLIENTE INT UNIQUE,
		FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE) 
	
	*/

		CREATE TABLE ENDERECO(	
			IDENDERECO INT PRIMARY KEY AUTO_INCREMENT,
			RUA VARCHAR(30) NOT NULL,
			BAIRRO VARCHAR(30) NOT NULL,
			CIDADE VARCHAR(30) NOT NULL,
			ESTADO CHAR(2) NOT NULL,
			ID_CLIENTE INT UNIQUE,
			FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE) 
		);
		
		CREATE TABLE TELEFONE(
			IDTELEFONE INT PRIMARY KEY AUTO_INCREMENT,
			TIPO ENUM('RES', 'COM', 'CEL') NOT NULL,
			NUMERO VARCHAR(10) NOT NULL,
			ID_CLIENTE INT,
			FOREIGN KEY(ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE) 
		);	
		
		/* 
		
		-------------INSERINDO DADOS---------------
		
		*/
		
		/* 
			o ID "NULL" diz que quem deve cuidar do id(primary key)
			é o proprio MySQL. Isso é necessário pois voce precisa indicar que está
			adicionando algo no banco.

		*/
		
		INSERT INTO CLIENTE VALUES(NULL,'JOAO', 'M', 'JOAO@IG.COM', '131312120');
		INSERT INTO CLIENTE VALUES(NULL,'CARLOS', 'M', 'CARLOS@IG.COM', '15334120');
		INSERT INTO CLIENTE VALUES(NULL,'ANA', 'F', 'ANAIG.COM', '6544512120');
		INSERT INTO CLIENTE VALUES(NULL,'CLARA', 'F', NULL, '65123120');
		INSERT INTO CLIENTE VALUES(NULL,'JORGE', 'M', 'JORGE@IG.COM', '65464520');
		INSERT INTO CLIENTE VALUES(NULL,'CELIA', 'F', 'CELIA@IG.COM', '7647672120');
		
		SELECT * FROM CLIENTE;
		
		+-----------+--------+------+---------------+------------+
		| IDCLIENTE | NOME   | SEXO | EMAIL         | CPF        |
		+-----------+--------+------+---------------+------------+
		|         7 | JOAO   | M    | JOAO@IG.COM   | 131312120  |
		|         8 | CARLOS | M    | CARLOS@IG.COM | 15334120   |
		|         9 | ANA    | F    | ANAIG.COM     | 6544512120 |
		|        10 | CLARA  | F    | NULL          | 65123120   |
		|        11 | JORGE  | M    | JORGE@IG.COM  | 65464520   |
		|        12 | CELIA  | F    | CELIA@IG.COM  | 7647672120 |
		+-----------+--------+------+---------------+------------+
		
		/* 
		
		[INSERINDO NAS TABELAS RELACIONADAS]
	
		****************** INSERÇÕES EM RELACIONAMENTOS 1 X 1 ******************
		
		*/
		
		INSERT INTO ENDERECO VALUES(NULL,'RUA ANTONIO SÁ','CENTRO','BELO HORIZONTE','MG', 10);
		INSERT INTO ENDERECO VALUES(NULL,'RUA CAPITAO HERMES','CENTRO','RIO DE JANEIRO','RJ', 7);
		INSERT INTO ENDERECO VALUES(NULL,'RUA PRES VARGAS','JARDINS','SÃO PAULO','SP', 9);
		INSERT INTO ENDERECO VALUES(NULL,'RUA ALFANDEGA','ESTÁCIO','RIO DE JANEIRO','RJ', 8);
		INSERT INTO ENDERECO VALUES(NULL,'RUA DO OUVIDOR','FLAMENGO','RIO DE JANEIRO','RJ', 12);
		INSERT INTO ENDERECO VALUES(NULL,'RUA URUGUAIANA','CENTRO','VITÓRIA','ES', 11);
		
		
		/* 
		
		EM RELACIONAMENTO 1 X 1 A CHAVE ESTRANGEIRA NAO SE REPETE
		*/
		
		/* ****************** INSERÇÕES EM RELACIONAMENTOS 1 X N ****************** */
		
		INSERT INTO TELEFONE VALUES(NULL, 'CEL','189981231',11);
		INSERT INTO TELEFONE VALUES(NULL, 'RES','189981231',7);
		INSERT INTO TELEFONE VALUES(NULL, 'COM','189981231',7);
		INSERT INTO TELEFONE VALUES(NULL, 'RES','189981231',8);
		INSERT INTO TELEFONE VALUES(NULL, 'CEL','189981231',11);
		INSERT INTO TELEFONE VALUES(NULL, 'COM','189981231',8);
		INSERT INTO TELEFONE VALUES(NULL, 'RES','189981231',7);
		INSERT INTO TELEFONE VALUES(NULL, 'RES','189981231',9);
		INSERT INTO TELEFONE VALUES(NULL, 'CEL','189981231',11);
		INSERT INTO TELEFONE VALUES(NULL, 'COM','189981231',9);
		INSERT INTO TELEFONE VALUES(NULL, 'CEL','189981231',11);
		
		/* **************************************************** */
		/* **************************************************** */
		/* **************************************************** */
		/* **************************************************** */
		
		/* SELEÇÃO E PROJEÇÃO */
		
		
		/* SELEÇÃO, PROJEÇÃO E JUNÇÃO */
		
		/*
			----> PROJEÇÃO (SELECT)
			
				É TUDO QUE VOCE QUER VER NA TELA.
		*/
		
		SELECT * FROM TELEFONE;
		SELECT NOW() AS DATA_ATUAL;
		
		SELECT 2 + 2 AS SOMA;
		
		SELECT 2 + 2 AS SOMA, NOME, NOW() FROM CLIENTE;
		
		/*
			----> PROJEÇÃO (SELECT)
			
				É TUDO QUE VOCE QUER VER NA TELA.
		*/

		
		SELECT * FROM TELEFONE;
		SELECT NOW() AS DATA_ATUAL;
		
		SELECT 2 + 2 AS SOMA;
		
		SELECT 2 + 2 AS SOMA, NOME, NOW() FROM CLIENTE;
		
		/*
			----> SELEÇÃO 
			
				SÃO OS FILTROS QUE TRAZEM UM SUBCONJUNTO DE UM CONJUNTO TOTAL
				SÃO CONDIÇÕES IMPOSTAS AO GRANDE CONJUNTO, QUE RETORNAM UM SUBCONJUNTO
				DE ACORDO COM OS PARAMETROS DEFINIDOS PELAS CONDIÇÕES.
				
				CLAUSULA WHERE;
				
		*/
		
		SELECT NOME, SEXO, EMAIL FROM CLIENTE WHERE SEXO = 'F';
		
		SELECT NOME AS CLIENTE_SEM_EMAIL, EMAIL /* PROJECAO */
		FROM CLIENTE /* ORIGEM */
		WHERE EMAIL IS NULL; /* SELECAO */
		
		
		/*
			----> JUNÇÃO ( JOIN )
				
				
				
				
		*/
		
		SELECT NOME, EMAIL, IDCLIENTE FROM CLIENTE;
		
		+--------+---------------+-----------+
		| NOME   | EMAIL         | IDCLIENTE |
		+--------+---------------+-----------+
		| JOAO   | JOAO@IG.COM   |         7 |
		| CARLOS | CARLOS@IG.COM |         8 |
		| ANA    | ANAIG.COM     |         9 |
		| CLARA  | NULL          |        10 |
		| JORGE  | JORGE@IG.COM  |        11 |
		| CELIA  | CELIA@IG.COM  |        12 |
		+--------+---------------+-----------+
		
		SELECT ID_CLIENTE, RUA, BAIRRO, CIDADE, ESTADO FROM ENDERECO;
		
		+------------+--------------------+----------+----------------+--------+
		| ID_CLIENTE | RUA                | BAIRRO   | CIDADE         | ESTADO |
		+------------+--------------------+----------+----------------+--------+
		|         10 | RUA ANTONIO SÁ     | CENTRO   | BELO HORIZONTE | MG     |
		|          7 | RUA CAPITAO HERMES | CENTRO   | RIO DE JANEIRO | RJ     |
		|          9 | RUA PRES VARGAS    | JARDINS  | SÃO PAULO      | SP     |
		|          8 | RUA ALFANDEGA      | ESTÁCIO  | RIO DE JANEIRO | RJ     |
		|         12 | RUA DO OUVIDOR     | FLAMENGO | RIO DE JANEIRO | RJ     |
		|         11 | RUA URUGUAIANA     | CENTRO   | VITÓRIA        | ES     |
		+------------+--------------------+----------+----------------+--------+
		
		/* IDCLIENTE, NOME, EMAIL, SEXO, RUA, BAIRRO, CIDADE, ESTADO, ID_CLIENTE 
		
			COMO POSSO FAZER ESSA PROJEÇÃO???????
		*/
		
		SELECT IDCLIENTE, NOME, EMAIL, SEXO, RUA, BAIRRO, CIDADE, ESTADO, ID_CLIENTE
		FROM CLIENTE, ENDERECO
		WHERE IDCLIENTE = ID_CLIENTE;
		
		+-----------+--------+---------------+------+--------------------+----------+----------------+--------+------------+
		| IDCLIENTE | NOME   | EMAIL         | SEXO | RUA                | BAIRRO   | CIDADE         | ESTADO | ID_CLIENTE |
		+-----------+--------+---------------+------+--------------------+----------+----------------+--------+------------+
		|         7 | JOAO   | JOAO@IG.COM   | M    | RUA CAPITAO HERMES | CENTRO   | RIO DE JANEIRO | RJ     |          7 |
		|         8 | CARLOS | CARLOS@IG.COM | M    | RUA ALFANDEGA      | ESTÁCIO  | RIO DE JANEIRO | RJ     |          8 |
		|         9 | ANA    | ANAIG.COM     | F    | RUA PRES VARGAS    | JARDINS  | SÃO PAULO      | SP     |          9 |
		|        10 | CLARA  | NULL          | F    | RUA ANTONIO SÁ     | CENTRO   | BELO HORIZONTE | MG     |         10 |
		|        11 | JORGE  | JORGE@IG.COM  | M    | RUA URUGUAIANA     | CENTRO   | VITÓRIA        | ES     |         11 |
		|        12 | CELIA  | CELIA@IG.COM  | F    | RUA DO OUVIDOR     | FLAMENGO | RIO DE JANEIRO | RJ     |         12 |
		+-----------+--------+---------------+------+--------------------+----------+----------------+--------+------------+
		
		/* ---------------- FUNCIONOU ------------------ MAS NÃO SE DEVE USAR NO DIA A DIA. ISSO É APENAS UMA PROJEÇÃO */
		
		
		/* FAZENDO DA FORMA CORRETA - INNER JOIN*/
		SELECT NOME EMAIL, SEXO, RUA, BAIRRO, CIDADE, ESTADO, IDCLIENTE, ID_CLIENTE
		FROM CLIENTE
		INNER JOIN ENDERECO
		ON IDCLIENTE = ID_CLIENTE;
		
		+--------+------+--------------------+----------+----------------+--------+-----------+------------+
		| EMAIL  | SEXO | RUA                | BAIRRO   | CIDADE         | ESTADO | IDCLIENTE | ID_CLIENTE |
		+--------+------+--------------------+----------+----------------+--------+-----------+------------+
		| JOAO   | M    | RUA CAPITAO HERMES | CENTRO   | RIO DE JANEIRO | RJ     |         7 |          7 |
		| CARLOS | M    | RUA ALFANDEGA      | ESTÁCIO  | RIO DE JANEIRO | RJ     |         8 |          8 |
		| ANA    | F    | RUA PRES VARGAS    | JARDINS  | SÃO PAULO      | SP     |         9 |          9 |
		| CLARA  | F    | RUA ANTONIO SÁ     | CENTRO   | BELO HORIZONTE | MG     |        10 |         10 |
		| JORGE  | M    | RUA URUGUAIANA     | CENTRO   | VITÓRIA        | ES     |        11 |         11 |
		| CELIA  | F    | RUA DO OUVIDOR     | FLAMENGO | RIO DE JANEIRO | RJ     |        12 |         12 |
		+--------+------+--------------------+----------+----------------+--------+-----------+------------+
		
		SELECT NOME EMAIL, SEXO, RUA, BAIRRO, CIDADE, ESTADO, IDCLIENTE, ID_CLIENTE
		FROM CLIENTE
		INNER JOIN ENDERECO
		ON IDCLIENTE = ID_CLIENTE
		WHERE SEXO = 'F';
		
		+-------+------+-----------------+----------+----------------+--------+-----------+------------+
		| EMAIL | SEXO | RUA             | BAIRRO   | CIDADE         | ESTADO | IDCLIENTE | ID_CLIENTE |
		+-------+------+-----------------+----------+----------------+--------+-----------+------------+
		| ANA   | F    | RUA PRES VARGAS | JARDINS  | SÃO PAULO      | SP     |         9 |          9 |
		| CLARA | F    | RUA ANTONIO SÁ  | CENTRO   | BELO HORIZONTE | MG     |        10 |         10 |
		| CELIA | F    | RUA DO OUVIDOR  | FLAMENGO | RIO DE JANEIRO | RJ     |        12 |         12 |
		+-------+------+-----------------+----------+----------------+--------+-----------+------------+
		
		/* 
		**************************************************
		UMA DÚVIDA: COMO EU FARIA UMA QUERY QUE ME RETORNASSE
		OS CLIENTES QUE NÃO POSSUEM NENHUM TELEFONE CADASTRADO? 
		**************************************************
		*/

				/* NOME, SEXO, EMAIL, TIPO, NUMERO */
		
		SELECT NOME, SEXO, EMAIL, TIPO, NUMERO
		FROM CLIENTE
		INNER JOIN TELEFONE
		ON IDCLIENTE = ID_CLIENTE;
		
		+--------+------+---------------+------+-----------+
		| NOME   | SEXO | EMAIL         | TIPO | NUMERO    |
		+--------+------+---------------+------+-----------+
		| JORGE  | M    | JORGE@IG.COM  | CEL  | 189981231 |
		| JOAO   | M    | JOAO@IG.COM   | RES  | 189981231 |
		| JOAO   | M    | JOAO@IG.COM   | COM  | 189981231 |
		| CARLOS | M    | CARLOS@IG.COM | RES  | 189981231 |
		| JORGE  | M    | JORGE@IG.COM  | CEL  | 189981231 |
		| CARLOS | M    | CARLOS@IG.COM | COM  | 189981231 |
		| JOAO   | M    | JOAO@IG.COM   | RES  | 189981231 |
		| ANA    | F    | ANAIG.COM     | RES  | 189981231 |
		| JORGE  | M    | JORGE@IG.COM  | CEL  | 189981231 |
		| ANA    | F    | ANAIG.COM     | COM  | 189981231 |
		| JORGE  | M    | JORGE@IG.COM  | CEL  | 189981231 |
		+--------+------+---------------+------+-----------+
		
		/* FAZENDO INNER JOIN COM MAIS DE UMA TABELA */
		
		
		/* NOME, SEXO, BAIRRO, CIDADE, TIPO, NUMERO*/
		
		SELECT NOME, SEXO, BAIRRO, CIDADE, TIPO NUMERO 
		FROM CLIENTE 
		INNER JOIN ENDERECO 
		ON IDCLIENTE = ID_CLIENTE
		INNER JOIN TELEFONE 
		ON IDCLIENTE = ID_CLIENTE;
		
		/* ERRO: ELE NÃO ENTENDE DE ONDE VEM O ID_CLIENTE
		JÁ QUE ELE ESTÁ PRESENTE NAS DUAS TABELAS.
		
		EXISTEM EMPRESAS QUE FAZEM AS CHAVES ESTRANGEIRAS COM NOMES
		DIFERENTES
		
		EX : 
		
		ID_CLIENTE_ENDERECO
		ID_CLIENTE_TELEFONE
		PRA EVITAR ESSA AMBIGUIDADE.
		
		
		RESOLUÇÃO: 
		*/
		
		SELECT CLIENTE.NOME, CLIENTE.SEXO, ENDERECO.BAIRRO, ENDERECO.CIDADE, TELEFONE.TIPO, TELEFONE.NUMERO 
		FROM CLIENTE 
		INNER JOIN ENDERECO 
		ON IDCLIENTE = ENDERECO.ID_CLIENTE
		INNER JOIN TELEFONE 
		ON IDCLIENTE = TELEFONE.ID_CLIENTE;
		
		/* ALIAS -> USABILIDADE */
		
		SELECT C.NOME, C.SEXO, E.BAIRRO,  E.CIDADE, T.TIPO, T.NUMERO 
		FROM CLIENTE C
		INNER JOIN ENDERECO E
		ON C.IDCLIENTE = E.ID_CLIENTE
		INNER JOIN TELEFONE T
		ON C.IDCLIENTE = T.ID_CLIENTE;
		
		/* *********************************************** */
		
		/* COMANDOS DE DML */
		
		/* 
		
		CATEGORIAS: 
		
			DML - DATA MANIPULATION LANGUAGE 
			DDL - DATA DEFINITION LANGUAGE
			DCL - DATA CONTROL LANGUAGE 
			TCL - TRANSACTION CONTROL LANGUAGE

		
		*/
		
		/* 
		-> DML (DATA MANIPULATION LANGUAGE): É USADO PARA MANIPULAR OS DADOS DENTRO DAS TABELAS DO BANCO DE DADOS.
		EXEMPLOS COMUNS DE COMANDOS DML INCLUEM SELECT (PARA RECUPERAR DADOS), INSERT (PARA ADICIONAR NOVOS DADOS), 
		UPDATE (PARA MODIFICAR DADOS EXISTENTES) E DELETE (PARA EXCLUIR DADOS).

		-> DDL (DATA DEFINITION LANGUAGE): É USADO PARA DEFINIR A ESTRUTURA E A ORGANIZAÇÃO DOS DADOS NO BANCO DE DADOS. 
		EXEMPLOS DE COMANDOS DDL INCLUEM CREATE (PARA CRIAR TABELAS, ÍNDICES, ETC.), ALTER (PARA MODIFICAR A ESTRUTURA EXISTENTE) E
		DROP (PARA EXCLUIR OBJETOS DO BANCO DE DADOS).

		-> DCL (DATA CONTROL LANGUAGE): É USADO PARA CONTROLAR OS PRIVILÉGIOS DE ACESSO AOS DADOS DENTRO DO BANCO DE DADOS. 
		OS PRINCIPAIS COMANDOS DCL INCLUEM GRANT (PARA CONCEDER PRIVILÉGIOS DE ACESSO A USUÁRIOS) E REVOKE (PARA REVOGAR ESSES PRIVILÉGIOS).

		-> TCL (TRANSACTION CONTROL LANGUAGE): É USADO PARA GERENCIAR AS TRANSAÇÕES DENTRO DO BANCO DE DADOS, 
		CONTROLANDO AS MUDANÇAS FEITAS PELOS COMANDOS DML. OS COMANDOS TCL MAIS COMUNS INCLUEM COMMIT (PARA CONFIRMAR AS 
		ALTERAÇÕES FEITAS EM UMA TRANSAÇÃO), ROLLBACK (PARA DESFAZER AS ALTERAÇÕES EM UMA TRANSAÇÃO) E 
		SAVEPOINT (PARA MARCAR PONTOS ESPECÍFICOS EM UMA TRANSAÇÃO PARA POSSÍVEL ROLLBACK POSTERIOR).
		*/
		
		/* DDL - MODIFICANDO TABELAS */
		/* DATA DEFINITION LANGUAGE */
		
		CREATE TABLE PRODUTO(
			IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
			NOME_PRODUTO VARCHAR(30) NOT NULL,
			PRECO INT, 
			FRETE FLOAT(10,2) NOT NULL
		);
		
		/* ALTER TABLE */
		/* ALTERANDO O NOME DE UMA COLUNA - CHANGE E MODIFY*/
		
		/* CHANGE  */
		
		ALTER TABLE PRODUTO 
		CHANGE PRECO VALOR_UNITARIO INT NOT NULL;
		
		+----------------+-------------+------+-----+---------+----------------+
		| Field          | Type        | Null | Key | Default | Extra          |
		+----------------+-------------+------+-----+---------+----------------+
		| IDPRODUTO      | int         | NO   | PRI | NULL    | auto_increment |
		| NOME_PRODUTO   | varchar(30) | NO   |     | NULL    |                |
		| VALOR_UNITARIO | int         | NO   |     | NULL    |                |
		| FRETE          | float(10,2) | NO   |     | NULL    |                |
		+----------------+-------------+------+-----+---------+----------------+
		
		/* TIRANDO O NOT NULL DE VALOR_UNITARIO */
		ALTER TABLE PRODUTO
		CHANGE VALOR_UNITARIO VALOR_UNITARIO INT;
		
		+----------------+-------------+------+-----+---------+----------------+
		| Field          | Type        | Null | Key | Default | Extra          |
		+----------------+-------------+------+-----+---------+----------------+
		| IDPRODUTO      | int         | NO   | PRI | NULL    | auto_increment |
		| NOME_PRODUTO   | varchar(30) | NO   |     | NULL    |                |
		| VALOR_UNITARIO | int         | YES  |     | NULL    |                |
		| FRETE          | float(10,2) | NO   |     | NULL    |                |
		+----------------+-------------+------+-----+---------+----------------+
		
		/* MODIFY  - MUITO UTIL PARA ALTERAR TIPOS */
			
		ALTER TABLE PRODUTO 	
		MODIFY VALOR_UNITARIO VARCHAR(50) NOT NULL;
		
		/* ADICIONANDO COLUNAS */
		
		ALTER TABLE PRODUTO
		ADD PESO FLOAT(10,2) NOT NULL;
		
		+----------------+-------------+------+-----+---------+----------------+
		| Field          | Type        | Null | Key | Default | Extra          |
		+----------------+-------------+------+-----+---------+----------------+
		| IDPRODUTO      | int         | NO   | PRI | NULL    | auto_increment |
		| NOME_PRODUTO   | varchar(30) | NO   |     | NULL    |                |
		| VALOR_UNITARIO | varchar(50) | NO   |     | NULL    |                |
		| FRETE          | float(10,2) | NO   |     | NULL    |                |
		| PESO           | float(10,2) | NO   |     | NULL    |                |
		+----------------+-------------+------+-----+---------+----------------+

		/* APAGANDO COLUNA  */

		ALTER TABLE PRODUTO
		DROP COLUMN PESO;
		
		/* ADICIONANDO COLUNA NA ORDEM ESPECÍFICA */
		
		ALTER TABLE PRODUTO 
		ADD COLUMN PESO FLOAT(10,2) NOT NULL
		AFTER NOME_PRODUTO;
		
		ALTER TABLE PRODUTO
		DROP COLUMN PESO;
		
		ALTER TABLE PRODUTO 
		ADD COLUMN PESO FLOAT(10, 2) NOT NULL
		FIRST;
		
		SHOW DATABASES;
		
		CREATE TABLE CATEGORY(
			ID INT PRIMARY KEY AUTO_INCREMENT,
			NAME VARCHAR(255) NOT NULL,
			TIER INT NOT NULL	
		);
		
		CREATE TABLE PRODUCT(
			ID INT PRIMARY KEY AUTO_INCREMENT,
			NAME VARCHAR(255) NOT NULL,
			PRICE FLOAT(10,2) NOT NULL,
			CATEGORY_ID INT,
			FOREIGN KEY(CATEGORY_ID) REFERENCES CATEGORY(ID)
		);
		
		INSERT INTO CATEGORY VALUES(NULL, 'TOOLS', 2);
		INSERT INTO CATEGORY VALUES(NULL, 'COMPUTERS',1);
		INSERT INTO CATEGORY VALUES(NULL, 'ELETRONICS', 1);
		
		INSERT INTO PRODUCT VALUES(NULL, 'Computer', 1100.0, 1);
		INSERT INTO PRODUCT VALUES(NULL, 'Hammer', 90.0, 2);
		INSERT INTO PRODUCT VALUES(NULL, 'Smart TV', 1700.0, 1);

		
		INSERT INTO CLIENTE VALUES(NULL,'FLAVIO','M','FLAVIO@IG.COM','4657765');
		INSERT INTO CLIENTE VALUES(NULL,'ANDRE','M','ANDRE@GLOBO.COM','7687567');
		INSERT INTO CLIENTE VALUES(NULL,'GIOVANA','F',NULL,'0876655');
		INSERT INTO CLIENTE VALUES(NULL,'KARLA','M','KARLA@GMAIL.COM','545676778');
		INSERT INTO CLIENTE VALUES(NULL,'DANIELE','M','DANIELE@GMAIL.COM','43536789');
		INSERT INTO CLIENTE VALUES(NULL,'LORENA','M',NULL,'774557887');
		INSERT INTO CLIENTE VALUES(NULL,'EDUARDO','M',NULL,'54376457');
		INSERT INTO CLIENTE VALUES(NULL,'ANTONIO','F','ANTONIO@IG.COM','12436767');
		INSERT INTO CLIENTE VALUES(NULL,'ANTONIO','M','ANTONIO@UOL.COM','3423565');
		INSERT INTO CLIENTE VALUES(NULL,'ELAINE','M','ELAINE@GLOBO.COM','32567763');
		INSERT INTO CLIENTE VALUES(NULL,'CARMEM','M','CARMEM@IG.COM','787832213');
		INSERT INTO CLIENTE VALUES(NULL,'ADRIANA','F','ADRIANA@GMAIL.COM','88556942');
		INSERT INTO CLIENTE VALUES(NULL,'JOICE','F','JOICE@GMAIL.COM','55412256');
		
		INSERT INTO ENDERECO VALUES(NULL,'RUA GUEDES','CASCADURA','B. HORIZONTE','MG',9);
		INSERT INTO ENDERECO VALUES(NULL,'RUA MAIA LACERDA','ESTACIO','RIO DE JANEIRO','RJ',10);
		INSERT INTO ENDERECO VALUES(NULL,'RUA VISCONDESSA','CENTRO','RIO DE JANEIRO','RJ',11);
		INSERT INTO ENDERECO VALUES(NULL,'RUA NELSON MANDELA','COPACABANA','RIO DE JANEIRO','RJ',12);
		INSERT INTO ENDERECO VALUES(NULL,'RUA ARAUJO LIMA','CENTRO','VITORIA','ES',13);
		INSERT INTO ENDERECO VALUES(NULL,'RUA CASTRO ALVES','LEBLON','RIO DE JANEIRO','RJ',14);
		INSERT INTO ENDERECO VALUES(NULL,'AV CAPITAO ANTUNES','CENTRO','CURITIBA','PR',15);
		INSERT INTO ENDERECO VALUES(NULL,'AV CARLOS BARROSO','JARDINS','SAO PAULO','SP',16);
		INSERT INTO ENDERECO VALUES(NULL,'ALAMEDA SAMPAIO','BOM RETIRO','CURITIBA','PR',17);
		INSERT INTO ENDERECO VALUES(NULL,'RUA DA LAPA','LAPA','SAO PAULO','SP',18);
		INSERT INTO ENDERECO VALUES(NULL,'RUA GERONIMO','CENTRO','RIO DE JANEIRO','RJ',19);
		INSERT INTO ENDERECO VALUES(NULL,'RUA GOMES FREIRE','CENTRO','RIO DE JANEIRO','RJ',20);
		INSERT INTO ENDERECO VALUES(NULL,'RUA GOMES FREIRE','CENTRO','RIO DE JANEIRO','RJ',8);
		
		INSERT INTO TELEFONE VALUES(NULL,'RES','68976565',9);
		INSERT INTO TELEFONE VALUES(NULL,'CEL','99656675',9);
		INSERT INTO TELEFONE VALUES(NULL,'CEL','33567765',11);
		INSERT INTO TELEFONE VALUES(NULL,'CEL','88668786',11);
		INSERT INTO TELEFONE VALUES(NULL,'COM','55689654',11);
		INSERT INTO TELEFONE VALUES(NULL,'COM','88687979',12);
		INSERT INTO TELEFONE VALUES(NULL,'COM','88965676',13);
		INSERT INTO TELEFONE VALUES(NULL,'CEL','89966809',15);
		INSERT INTO TELEFONE VALUES(NULL,'COM','88679978',16);
		INSERT INTO TELEFONE VALUES(NULL,'CEL','99655768',17);
		INSERT INTO TELEFONE VALUES(NULL,'RES','89955665',18);
		INSERT INTO TELEFONE VALUES(NULL,'RES','77455786',19);
		INSERT INTO TELEFONE VALUES(NULL,'RES','89766554',19);
		INSERT INTO TELEFONE VALUES(NULL,'RES','77755785',10);
		INSERT INTO TELEFONE VALUES(NULL,'COM','44522578',10);
		
		/* EXERCÍCIOS DML */
		
		/* RELATORIO GERAL DE TODOS OS CLIENTES */
		
		SELECT IDCLIENTE, NOME, EMAIL, CPF, CIDADE, ESTADO, NUMERO, TIPO
		FROM CLIENTE C
		INNER JOIN ENDERECO E
		ON C.IDCLIENTE = E.ID_CLIENTE
		INNER JOIN TELEFONE T
		ON C.IDCLIENTE = T.ID_CLIENTE;
		
		/* RELATORIO DE HOMENS */
		
		SELECT IDCLIENTE, NOME, EMAIL, SEXO, CPF, CIDADE, ESTADO, NUMERO, TIPO
		FROM CLIENTE C
		INNER JOIN ENDERECO E
		ON C.IDCLIENTE = E.ID_CLIENTE
		INNER JOIN TELEFONE T
		ON C.IDCLIENTE = T.ID_CLIENTE
		WHERE C.SEXO = 'M';
		
		/* RELATORIO DE MULHERES */
			
		SELECT IDCLIENTE, NOME, EMAIL, SEXO, CPF, CIDADE, ESTADO, NUMERO, TIPO
		FROM CLIENTE C
		INNER JOIN ENDERECO E
		ON C.IDCLIENTE = E.ID_CLIENTE
		INNER JOIN TELEFONE T
		ON C.IDCLIENTE = T.ID_CLIENTE
		WHERE C.SEXO = 'F';
		
		/* QUANTIDADE DE HOMENS E MULHERES */
		
		SELECT SEXO, COUNT(*) 
		FROM CLIENTE 
		GROUP BY SEXO;
		
		/* IDS E EMAIL DAS MULHERES QUE MOREM NO CENTRO DO RIO DE JANEIRO E NAO TENHAM CELULAR */
		
		SELECT IDCLIENTE, NOME, EMAIL, TIPO, NUMERO, BAIRRO, ESTADO
		FROM CLIENTE C
		INNER JOIN ENDERECO E ON C.IDCLIENTE = E.ID_CLIENTE
		INNER JOIN TELEFONE T ON C.IDCLIENTE = T.ID_CLIENTE
		WHERE C.SEXO = 'F' 
		AND E.ESTADO = 'RJ'
		AND E.BAIRRO = 'CENTRO'
		AND T.NUMERO IS NULL;
		
		/* ****************************************** */
		/* **************** CORREÇÃO **************** */
		/* ****************************************** */

#AULA265 

- JDBC (Java Database Connectivity): API padrão do java para aceso a dados.
- pacoes: java.sql e javax.sql (API suplementar para servidores)

Resumo: o JDBC fornece um driver na sua aplicação -> JDBC Driver Manager

e ele vai converter o código para os bancos de dados a serem utilizados.

#AULA266

- Operações básicas da álgebra relacional

    . Restrição
    . Projeção
    . Produto Cartesiano
    . Junção(produto cartesiano + restrição de chaves correspondentes)

#AULA270

- Organizando projeto para o CRUD com banco de dados utilizando o JDBC 
(JAVA DATABASE CONNECTOR) 

. Adicionar a biblioteca do jdbc na pasta raiz, ou adicionar lib.

. Criar db.properties na pasta raiz do projeto.
	. Inserir campos
		- user:
		- password:
		- dburl: 
		+useSSL: false (ainda não sei para que serve)

- Classe DbException
	O professor criou a classe DbException que estende RuntimeException para encapsular exceções específicas do banco de dados 
	que podem ocorrer durante a execução do código. Isso é uma boa prática por várias razões:

	Encapsulação de Exceções: Ao encapsular exceções específicas do banco de dados em uma classe personalizada como DbException, 
	você torna o código mais legível e mais fácil de entender. Em vez de lidar com exceções genéricas ou específicas do JDBC em 
	cada ponto onde ocorrem, você pode usar uma única classe para representar todas as exceções relacionadas ao banco de dados.

	Abstração de Detalhes de Implementação: Usar uma classe personalizada para exceções relacionadas ao banco de dados ajuda a 
	abstrair os detalhes de implementação do banco de dados do restante do código. Isso permite que você altere o provedor de banco 
	de dados ou faça outras mudanças na camada de persistência sem precisar modificar o código em outros lugares.

	Centralização de Tratamento de Exceções: Ao capturar exceções específicas do banco de dados em um único lugar (por exemplo, 
	nos métodos de conexão da classe DB), você centraliza o tratamento de exceções relacionadas ao banco de dados. Isso facilita a
	manutenção do código, pois você pode lidar com todas as exceções relacionadas ao banco de dados de maneira consistente em um único local.

	Facilidade de Manutenção: Usar uma classe personalizada para exceções relacionadas ao banco de dados pode tornar a manutenção 
	do código mais fácil no futuro. Se você precisar adicionar mais informações à mensagem de erro ou implementar tratamentos específicos 
	para diferentes tipos de exceções, pode fazer isso facilmente na classe DbException.

	Em resumo, encapsular exceções específicas do banco de dados em uma classe personalizada como DbException é uma prática 
	recomendada porque torna o código mais legível, abstrai detalhes de implementação, centraliza o tratamento de exceções e facilita a manutenção do código no futuro.

- Atributo Connection conn = null
	. É o atributo objeto que encapsula a conexão.
	. Dentro do método getConnection() o método verifica se existe uma conexão(conn != null) e se estiver vazio recebe uma nova conexão
	a partir de conn = DriverManager.getConnection("urlBanco", "propsDeDb.properties")

	-  public static Connection getConnection() {
       try {
           if(conn == null) {
               Properties props = loadProperties();
               String url = props.getProperty("dburl");
               /* Classe que vai fazer conexão com o banco de dados */
               conn = DriverManager.getConnection(url, props);
           }
           return conn;
       } catch (SQLException e) {
           throw new DbException(e.getMessage());
       }
    }


- Atributo Properties props - o que ele significa? 
	. É o objeto que encapsula as informações de db.properties.
	. Ele é usado em GetConnection()
	. Elaborado em loadProperties()
	
	- private static Properties loadProperties() {
       try(FileInputStream fs = new FileInputStream(url)) {
            Properties props = new Properties();
            props.load(fs);
            return props;
       } catch(IOException e) {
            throw new DbException(e.getMessage());
       }
    }